# Walk through Example

In this example let us create an Esmerald application that will be using the **Esmerald Admin** but
with some complexity and organisation.

In this walk-through we will be also making sure we use as many Esmerald built-ins as possible.

## What we will be using

* [Esmerald directives][directives] - To generate a project scaffold with a given organisation.
* [Esmerald contrib models for Saffier][models] - To be easier to use some of the functionalities.
* [Saffier ORM][saffier] - The main ORM for this package.
* [Esmerald admin EmailAdminAuth](./authentication.md#emailadminauth-and-usernameadminauth) -
The backend auth for the admin.

## What is the structure of this example

* [Initial project setup](#initial-project-setup)
* [Generate migrations](#generate-migrations)
* [Add the Esmerald admin](#add-the-esmerald-admin)

**Lets do it!**

## Initial project setup

### Generate the project

First we will be gerating the project to work on. Using the Esmerald [directives][directives] this
should be easy and lets call it **myproject**.

```shell
$ esmerald createproject myproject
```

You should now have a folder structure similar to this:

```shell
.
â”œâ”€â”€ Makefile
â””â”€â”€ myproject
    â”œâ”€â”€ apps
    â”‚Â Â  â””â”€â”€ __init__.py
    â”œâ”€â”€ configs
    â”‚Â Â  â”œâ”€â”€ development
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â””â”€â”€ settings.py
    â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”œâ”€â”€ settings.py
    â”‚Â Â  â””â”€â”€ testing
    â”‚Â Â      â”œâ”€â”€ __init__.py
    â”‚Â Â      â””â”€â”€ settings.py
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ main.py
    â”œâ”€â”€ serve.py
    â”œâ”€â”€ tests
    â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â””â”€â”€ test_app.py
    â””â”€â”€ urls.py
```

This is the default folder structure generated by `createproject` command from Esmerald but you
can ready more about [Esmerald directives][directives] in its [official documentation][esmerald]

From now on, let us work inside the new project.

```shell
$ cd myproject/
```

### Generate an Esmerald application

Since we want the project to have a clean design and clean structure, let us then create an
Esmerald application.

Lets `cd` to `apps`.

```shell
$ cd myproject/apps/
```

Here we want to create an `accounts application. What is this? Simply a package that will handle
with all things user and user management in `myproject`.

```shell
$ esmerald createproject accounts
```

Now we have a structure like this:

```shell hl_lines="5-16"
.
â”œâ”€â”€ Makefile
â””â”€â”€ myproject
    â”œâ”€â”€ apps
    â”‚Â Â  â”œâ”€â”€ accounts
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ directives
    â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ operations
    â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests.py
    â”‚Â Â  â”‚Â Â  â””â”€â”€ v1
    â”‚Â Â  â”‚Â Â      â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â      â”œâ”€â”€ schemas.py
    â”‚Â Â  â”‚Â Â      â”œâ”€â”€ urls.py
    â”‚Â Â  â”‚Â Â      â””â”€â”€ views.py
    â”‚Â Â  â””â”€â”€ __init__.py
    â”œâ”€â”€ configs
    â”‚Â Â  â”œâ”€â”€ development
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â””â”€â”€ settings.py
    â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”œâ”€â”€ settings.py
    â”‚Â Â  â””â”€â”€ testing
    â”‚Â Â      â”œâ”€â”€ __init__.py
    â”‚Â Â      â””â”€â”€ settings.py
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ main.py
    â”œâ”€â”€ serve.py
    â”œâ”€â”€ tests
    â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â””â”€â”€ test_app.py
    â””â”€â”€ urls.py

```

Great! We now have a nice structured project with an `accounts` application where we will be
managing the [Saffier][saffier] models.

### Create the user model

Now that we have our initial structure, it is time to create our `User` model. As mentioned at the
very beginning, we will be using the [Esmerald contrib][models] since a lot is already provided.

Let us cd to `accounts` and create a `models.py`.

```shell
$ cd myproject/apps/accounts
$ touch models.py
```

```shell hl_lines="11"
.
â”œâ”€â”€ Makefile
â””â”€â”€ myproject
    â”œâ”€â”€ apps
    â”‚Â Â  â”œâ”€â”€ accounts
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ directives
    â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ operations
    â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests.py
    â”‚Â Â  â”‚Â Â  â””â”€â”€ v1
    â”‚Â Â  â”‚Â Â      â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â      â”œâ”€â”€ schemas.py
    â”‚Â Â  â”‚Â Â      â”œâ”€â”€ urls.py
    â”‚Â Â  â”‚Â Â      â””â”€â”€ views.py
    â”‚Â Â  â””â”€â”€ __init__.py
...

```

Open the file and add the following:

```python hl_lines="2 4 11"
{!> ../docs_src/example/models.py !}
```

This creates a model `User` that inherits from the `AbstractUser` from Esmerald and uses the
`models` for the registry. More details about the registry in the official [Saffier][saffier]
documentation.

Let the line `database, models = settings.db_access` be like that as we will be updating the
application settings later on to reflect the `db_access`.

### Make the user model accessible

To make sure Saffier can see the models and then use them to manage the migrations, let us add
the User to the `__init__.py` of the accounts.

Open **myproject/apps/accounts/__init__.py** and add the following line:

```python
from .models import User as User
```

This should be enough to expose our models to the application.

### Add an initial view to application

Since we want an application, it will be nice to add at least a welcome view to it.

Go to **myproject/apps/accounts/v1/views.py** and add the following:

```python
{!> ../docs_src/example/views.py !}
```

And then go to **myproject/apps/accounts/v1/urls.py** to connect the handler with a Gateway.

```python
{!> ../docs_src/example/urls.py !}
```

So far so good. We now have views, urls, models and applications. The application is becoming
more complex.

### Add the newly created endpoints to the main application routing system

This system is not a default from Esmerald, instead is simply one of the many designs that you can
adopt when managing URL endpoints in your application. When using the Esmerald **createproject**
directive, it simply generates one structure that makes it simpler to do it.

Now it is time to add those `accounts` urls to the main application routing system.

Go to **myproject/urls.py** and add the following:

```python
from esmerald import Include

route_patterns = [Include(path="/accounts", namespace="accounts.v1.urls")]
```

The way the routing system works with Esmerald can be found in the [official documentation][esmerald].

The reason why we did in this way it is because the **createaproject** generates a unique and clean
structure where inside the `main.py` file the function `get_application` imports the `urls.py`
as the initial route.

```python title="myproject/main.py" hl_lines="8"
def get_application():
    """
    This is optional. The function is only used for organisation purposes.
    """
    build_path()

    app = Esmerald(
        routes=[Include(namespace="myproject.urls")],
    )

    return app
```

This can of course be changed but we want to simplify as much as possible in this example.

### Access the welcome endpoint

After all of this, you can now start the project and access the OpenAPI docs and test your URL.

Go back to your `myproject` root folder and run:

```shell
esmerald runserver
```

Access the `http://localhost:8000/docs/swagger` and you should be able to see the welcome endpoint.

## Generate migrations

Now it is time to generate some migrations for our example. Remember the `User` model created
before and the way it was exposed? Well it is time now to make sure we are able to generate
migrations with saffier.

First we need to initialise the migration system for our **myproject** and according to
[Saffier](https://saffier.tarsild.io/migrations/discovery/) we need to expose some environment
variables or use the `--app` parameter.

For the simplificy of this example, let us use environment variables.

We will be using Postgres with a database called `mydb`.

1. Expose our database url:

```shell
export SAFFIER_DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/mydb
```

2. Expose the `ESMERALD_SETTINGS_MODULE` we need to use for our development purposes.

```shell
export ESMERALD_SETTINGS_MODULE=myproject.configs.development.settings.DevelopmentAppSettings
```

This matches the location of the `settings.py` file inside the generated scaffold for development.
These settings inherit from the `AppSettings` that should be used for production.

```shell hl_lines="23"
.
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Makefile
â””â”€â”€ myproject
    â”œâ”€â”€ apps
    â”‚Â Â  â”œâ”€â”€ accounts
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ directives
    â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ operations
    â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests.py
    â”‚Â Â  â”‚Â Â  â””â”€â”€ v1
    â”‚Â Â  â”‚Â Â      â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â      â”œâ”€â”€ schemas.py
    â”‚Â Â  â”‚Â Â      â”œâ”€â”€ urls.py
    â”‚Â Â  â”‚Â Â      â””â”€â”€ views.py
    â”‚Â Â  â””â”€â”€ __init__.py
    â”œâ”€â”€ configs
    â”‚Â Â  â”œâ”€â”€ development
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â””â”€â”€ settings.py
    â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”œâ”€â”€ settings.py
    â”‚Â Â  â””â”€â”€ testing
    â”‚Â Â      â”œâ”€â”€ __init__.py
    â”‚Â Â      â””â”€â”€ settings.py
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ main.py
    â”œâ”€â”€ serve.py
    â”œâ”€â”€ tests
    â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â””â”€â”€ test_app.py
    â””â”€â”€ urls.py

```

### Initialisation

Now that we have our environment ready with the environment variables in the right place, inside
the root of **myproject**, run:

```shell
saffier init
```

This will generate the `migrations` folder and you should now have something like this:

```shell hl_lines="4-9"
.
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Makefile
â”œâ”€â”€ migrations
â”‚Â Â  â”œâ”€â”€ alembic.ini
â”‚Â Â  â”œâ”€â”€ env.py
â”‚Â Â  â”œâ”€â”€ README
â”‚Â Â  â”œâ”€â”€ script.py.mako
â”‚Â Â  â””â”€â”€ versions
â””â”€â”€ myproject
    â”œâ”€â”€ apps

```

Pretty cool, right? Well Saffier has its own migration system on the top of Alembic and makes it
easier to manage.

### Update the settings

Well, you came far if you are reading this. Remember exposing the `ESMERALD_SETTINGS_MODULE` before?
And do you remember the `DevelopmentAppSettings` inherits from `AppSettings`?

This is very useful because it means we only need to update in one place and the rest will simply
use it.

Go to **myproject/configs/settings.py** and update the contents with the following.

```python hl_lines="18-19"
{!> ../docs_src/example/settings.py !}
```

These are very important configurations. Let us go through. If you remember at the beginning
of this example, the `User` [model was declared](#create-the-user-model) and there was a `db_access`
being called from the `esmerald.conf.settings`.

!!! Check
    The highlighted section is how you have created that property and made it globaly available in your
    application and the reason why is globaly available it is because you have also exposed the
    `ESMERALD_SETTINGS_MODULE` environment variable before which means the application will be running
    using your **custom settings and not the default Esmerald settings**. ðŸ”¥

The `jwt_config` let it be like this as it will be useful later on ðŸ˜.

### Update the main file

Now it is time to update the `main.py` file and add the [Saffier][saffier] migration management
system.

Go to **myproject/main.py** and update with the following:

```python hl_lines="5 34 38-39 43"
{!> ../docs_src/example/app.py !}
```

Well, now the things are getting more complete, aren't they? So this is very simple to explain:

1. Import the `settings` from the `esmerald.conf` to allow to access the `db_access` property.
The `db_access` property as it was declared in the settings, is a `cached_property` and that is
very helpful because we want the registry used in the models to be exactly the same as the one
used for the migrations.
2. `on_startup/on_shutdown` events are used and needed for the application to interact with the
database.
3. `get_migrations()` is a new function we created to simply make it readable and cleaner to us.

!!! Warning
    Because the `db_access` is the same everywhere in the models and in the application, we can
    simply just pass the `registry` to the `Migrate` object of saffier.

### Run your first migration

Now you can run your first migration and generate your database tables.

Go to the root of **myproject** and run:

```shell
$ saffier makemigrations
$ saffier migrate
```

Your `migrations` folder should now contain your first migration file with the declaration of
the [User model](#create-the-user-model).

### Generate a superuser

Remember the reason why using the Esmerald contrib? Well, one of the reasons it is because it is
ready to manage users, staff and superusers out-of-the box as well.

We now want to create a superuser that will be later used to login into the **Esmerald admin**. To
perform this operation we will be using **another** [Esmerald directive][directives].

Go to **myproject/apps/accounts/directives/operations** and run:

```shell
$ touch createsuperuser.py
```

It should like this

```shell hl_lines="15"
.
â”œâ”€â”€ Makefile
â”œâ”€â”€ migrations
â”‚Â Â  â”œâ”€â”€ alembic.ini
â”‚Â Â  â”œâ”€â”€ env.py
â”‚Â Â  â”œâ”€â”€ README
â”‚Â Â  â”œâ”€â”€ script.py.mako
â”‚Â Â  â””â”€â”€ versions
â””â”€â”€ myproject
    â”œâ”€â”€ apps
    â”‚Â Â  â”œâ”€â”€ accounts
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ directives
    â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ operations
    â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ createsuperuser.py
    â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models.py
...
```

Edit the new `createsuperuser.py` and add the following.

```python hl_lines="6"
{!> ../docs_src/example/createsuperuser.py !}
```

This is an extremely powerfull [custom directive][custom_directive] from Esmerald that allows to run custom scripts
within your Esmerald application.

We can now create a super user by running the following command inside the root of **myproject**:

```shell
esmerald run --directive createsuperuser --first-name John --last-name Doe --email john.doe@example.com --username johnd --password pass1234
```

## Add the Esmerald admin

Now it is time for the last bit. Adding the Esmerald admin to your application. If you complete
all the previous steps, this one should be easy!

### Create the admin file

Well, here this is not mandatory, you can have all the admin views inside your `main.py` file as
a lot of people usually do but since it was mentioned the clean design using Esmerald, let us keep
it in a separate file called `admin.py`.

Go to **myproject/** and run:

```shell
$ touch admin.py
```

You should now have a structure like this:

```shell hl_lines="10"
.
â”œâ”€â”€ Makefile
â”œâ”€â”€ migrations
â”‚Â Â  â”œâ”€â”€ alembic.ini
â”‚Â Â  â”œâ”€â”€ env.py
â”‚Â Â  â”œâ”€â”€ README
â”‚Â Â  â”œâ”€â”€ script.py.mako
â”‚Â Â  â””â”€â”€ versions
â””â”€â”€ myproject
    â”œâ”€â”€ admin.py
...
```

### Create the admin views

Now it is time to create the admin views. This is a very important step since [Saffier][saffier] is
kinda unique in the way it does things.

Esmerald admin being derived from SQLAdmin has some particularities. Saffier natively is very fast
since it is created on the top of SQLAlchemy Core but SQLAdmin expects `declarative_models` types.

Saffier also provides that and those are the ones that **should** be used for the admin.
You can see [more details][declarative_models] about how Saffier manages the declarative_models.

Now, go to **myproject/admin.py** and add the following:

```python hl_lines="1 6 9"
{!> ../docs_src/example/admin.py !}
```

As you can see, the User model is a normal Saffier model but for the admin what we want is the
declarative version of it, the one that SQLAdmin expects to receive and use.

!!! Warning
    Make sure you read the [official documentation][declarative_models] to understand in detail
    how to work with declarative models and the relations.

#### Important

When [SQLAdmin](https://aminalaee.dev/sqladmin/api_reference/model_view/#sqladmin.models.ModelView.form_ajax_refs)
refers to `ForeignKey` relationships using ajax, [Saffier][declarative_models] declarative models
add a suffix `_relation` to the name of the declared ForeignKey.

**Example**:

```python hl_lines="20-29"
{!> ../docs_src/example/attention.py !}
```

As you can see, the model Thread has two foreign keys, sender and receiver. In a normal Saffier ORM operation,
this remains as is but if you generate the declarative() model from Saffier then it will create automatically the following fields:

* `sender_relation`
* `receiver_relation`

And this becomes like the following:

!!! Example
    ```python
    class UserAdmin(ModelAdmin, model=User):
        column_list = [User.id, User.email, User.first_name, User.last_name]
        form_ajax_refs = {
            'sender_relation': {
                'fields': ('email', 'first_name'),
            },
            'receiver_relation': {
                'fields': ('email', 'first_name'),
            }
        }
    ```

### Connect the admin with Esmerald

Now it is the time to connect your newly created admin with your Esmerald application.

Go to **myproject/main.py** and update to the following:

```python hl_lines="8-9 31-45 66"
{!> ../docs_src/example/app_updated.py !}
```

This now contains all the needed ingredients for the admin to work.

* The `Admin` is imported from `esmerald_admin` package.
* The [EmailAdminAuth](./authentication.md#emailadminauth-and-usernameadminauth) is being used
as the backend authentication of the `admin`.
* The `get_views()` created in `my_project/admin.py` is being imported inside the `get_admin()`.
* The `jwt_config` previously set in the [settings](#update-the-settings) its being used in this
admin configuration.
* The `get_admin` is being called upon the instantiation of the Esmerald application.

### Access the admin

Now it is time to finally access the admin.

Go to the root of **myproject** and run:

```shell
$ esmerald runserver
```

This will start the server in development mode and then in your browser go to `http://localhost:8000/admin/`
and login using the information previously created when the [super user](#generate-a-superuser) was
created.

```ini
email: "john.doe@example.com"
password: "pass1234"
username: "johnd"
```

!!! Warning
    Although in the UI you see `username`, the `EmailAdminAuth` uses the email to login. If you
    really want to use the `username` instead of the email, use the `UsernameAdminAuth` instead.


And this is it. Quite a complex structure, clean, tidy and ready to use with Esmerald admin.

## Notes

As described numerous times, 90% of the functionalities used with Esmerald admin are the same as
the [SQLAdmin](https://aminalaee.dev/sqladmin) as it is built on the top of it so make sure you
also read the docs and start the repository as it was a lot of work from
[@aminalaee](https://github.com/aminalaee) to get this working so well and without his work, this
would not be possible.

[esmerald]: https://esmerald.dev
[directives]: https://esmerald.dev/directives/directives/
[custom_directive]: https://esmerald.dymmond.com/directives/custom-directives/
[models]: https://esmerald.dev/databases/saffier/models/
[saffier]: https://saffier.tarsild.io/
[declarative_models]: https://saffier.tarsild.io/declarative-models/
